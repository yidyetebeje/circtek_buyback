import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useEffect, useCallback, useMemo, useState } from 'react';
import { useRouter, usePathname } from '@/i18n/navigation';
import { useParams } from 'next/navigation';
// Import React Query conditionally to avoid server-side issues
import {
  Language,
  LanguageState,
  availableLanguagesAtom,
  currentLanguageAtom,
  currentLanguageStateAtom,
  currentLanguageObjectAtom,
  languageLoadingAtom,
  setLanguageAction
} from '@/store/atoms';

/**
 * Custom hook for language management
 * Handles language detection, API calls, and state management
 */
export function useLanguage() {
  const [availableLanguages, setAvailableLanguages] = useAtom(availableLanguagesAtom);
  const [languageState, setLanguageState] = useAtom(currentLanguageStateAtom);
  const currentLanguage = useAtomValue(currentLanguageAtom);
  const currentLanguageObject = useAtomValue(currentLanguageObjectAtom);
  const [isLoading, setIsLoading] = useAtom(languageLoadingAtom);
  const setLanguage = useSetAtom(setLanguageAction);
  const router = useRouter();
  const pathname = usePathname();
  const params = useParams();

  // Get current locale from URL
  const urlLocale = (params?.locale as string) || 'en';

  /**
   * Detect user's preferred language based on browser and location
   * Memoized for performance
   */
  const detectUserLanguage = useMemo((): string => {
    // Get browser language preferences
    const browserLanguages = navigator.languages || [navigator.language];
    const primaryBrowserLang = browserLanguages[0]?.split('-')[0] || 'en';

    // For location-based detection, you could use a geolocation service
    // For now, we'll use browser language as primary indicator
    const supportedCodes = availableLanguages.map(lang => lang.code);
    
    // Check if browser language is supported
    if (supportedCodes.includes(primaryBrowserLang)) {
      return primaryBrowserLang;
    }

    // Fallback to default language
    const defaultLang = availableLanguages.find(lang => lang.isDefault);
    return defaultLang?.code || 'en';
  }, [availableLanguages]);

  // Server-safe implementation that doesn't use React Query during SSR
  const [languages, setLanguages] = useState<Language[] | null>(null);
  const [isQueryLoading, setIsQueryLoading] = useState(false);
  
  /**
   * Fetch available languages directly with fetch API
   * This can be used in both client and server environments
   */
  const fetchLanguages = useCallback(async () => {
    try {
      setIsLoading(true);
      setIsQueryLoading(true);
      
      const response = await fetch('/api/catalog/languages?limit=50');
      
      if (!response.ok) {
        throw new Error('Failed to fetch languages');
      }

      const data = await response.json();
      
      // Transform API response to match our Language interface
      const languagesData = data.data?.map((lang: {
        id: number;
        code: string;
        name: string;
        is_default?: number;
        is_active?: number;
      }) => ({
        id: lang.id.toString(),
        code: lang.code,
        name: lang.name,
        nativeName: lang.name, // Use name as nativeName for now
        flag: undefined, // Will be generated by getLanguageFlag
        isDefault: Boolean(lang.is_default),
        isActive: Boolean(lang.is_active)
      })) || [];
      
      // Update both local state and Jotai atom
      setLanguages(languagesData);
      setAvailableLanguages(languagesData);
      
      return languagesData;
    } catch (error) {
      console.error('Error fetching languages:', error);
      
      // Fallback to default languages if API fails
      const fallbackLanguages = [
        { id: '1', code: 'en', name: 'English', nativeName: 'English', isDefault: true, isActive: true },
        { id: '2', code: 'nl', name: 'Dutch', nativeName: 'Nederlands', isDefault: false, isActive: true },
        { id: '3', code: 'fr', name: 'French', nativeName: 'FranÃ§ais', isDefault: false, isActive: true },
        { id: '4', code: 'de', name: 'German', nativeName: 'Deutsch', isDefault: false, isActive: true }
      ];
      
      // Update both local state and Jotai atom
      setLanguages(fallbackLanguages);
      setAvailableLanguages(fallbackLanguages);
      
      return fallbackLanguages;
    } finally {
      setIsLoading(false);
      setIsQueryLoading(false);
    }
  }, [setAvailableLanguages, setIsLoading]);

  /**
   * Change the current language and update URL
   * Optimized and simplified implementation
   * @param languageCode The language code to change to
   * @param options Configuration options
   */
  const changeLanguage = useCallback((languageCode: string, options: { updateUrl?: boolean } = {}) => {
    // Default options
    const { updateUrl = true } = options;
    
    // Early return if language is invalid or already selected
    if (!availableLanguages.some(lang => lang.code === languageCode && lang.isActive) || 
        (currentLanguage === languageCode && urlLocale === languageCode)) {
      return;
    }
    
    try {
      // Update state directly
      setLanguage(languageCode);
      
      // Update URL if needed
      if (updateUrl) {
        router.replace(pathname, { locale: languageCode });
      }
    } catch (error) {
      console.warn('Failed to change language:', error);
    }
  }, [availableLanguages, setLanguage, router, pathname, currentLanguage, urlLocale]);

  /**
   * Get language flag emoji or URL
   */
  const getLanguageFlag = useCallback((code: string): string => {
    const flagMap: Record<string, string> = {
      'en': 'ðŸ‡ºðŸ‡¸',
      'nl': 'ðŸ‡³ðŸ‡±',
      'fr': 'ðŸ‡«ðŸ‡·',
      'de': 'ðŸ‡©ðŸ‡ª',
      'es': 'ðŸ‡ªðŸ‡¸',
      'it': 'ðŸ‡®ðŸ‡¹',
      'pt': 'ðŸ‡µðŸ‡¹',
      'ru': 'ðŸ‡·ðŸ‡º',
      'zh': 'ðŸ‡¨ðŸ‡³',
      'ja': 'ðŸ‡¯ðŸ‡µ',
      'ko': 'ðŸ‡°ðŸ‡·'
    };
    
    return flagMap[code] || 'ðŸŒ';
  }, []);

  // Sync URL locale with internal state - with better version tracking
  useEffect(() => {
    // Only sync if URL locale is valid and different from current language
    if (urlLocale && 
        urlLocale !== currentLanguage && 
        availableLanguages.some(lang => lang.code === urlLocale && lang.isActive)) {
      
      // Update without URL change or version increment
      setLanguage(urlLocale);
    }
  }, [urlLocale, currentLanguage, availableLanguages, setLanguage]);

  // Initialize languages on mount
  useEffect(() => {
    if (availableLanguages.length === 0 && !isLoading) {
      fetchLanguages();
    }
  }, [availableLanguages.length, fetchLanguages, isLoading]);
  
  return {
    // State
    availableLanguages,
    currentLanguage,
    currentLanguageObject,
    languageState,
    urlLocale,
    isLoading: isLoading || isQueryLoading,
    
    // Actions
    fetchLanguages,
    detectUserLanguage,
    changeLanguage,
    setLanguage,
    getLanguageFlag,
    
    // Utilities
    isLanguageSupported: (code: string) => availableLanguages.some(lang => lang.code === code && lang.isActive)
  };
}